import httpx
from app.config import Config
from app.services.gemini_service import GeminiService
from app.schemas.transit import TransitResponse, TransitRouteStep
from app.utils.error_handling import handle_api_error
from typing import List
import asyncio
import json

class TransitService:
    def __init__(self):
        self.gemini_service = GeminiService()

    async def fetch_transit_data(self, start: str, end: str) -> dict:
        async with httpx.AsyncClient() as client:
            for attempt in range(Config.RATE_LIMIT_RETRIES):
                try:
                    response = await client.get(
                        f"{Config.TRANSIT_API_URL}/routes",
                        params={"start": start, "end": end},
                        timeout=10.0
                    )
                    response.raise_for_status()
                    data = response.json()
                    # Validate data consistency
                    if not data.get("routes") or not isinstance(data["routes"], list):
                        raise ValueError("Invalid transit data format")
                    return data
                except (httpx.HTTPStatusError, ValueError) as e:
                    if isinstance(e, httpx.HTTPStatusError) and e.response.status_code == 429 and attempt < Config.RATE_LIMIT_RETRIES - 1:
                        await asyncio.sleep(2 ** attempt)
                        continue
                    handle_api_error(e)
            raise HTTPException(status_code=429, detail="Transit API rate limit exceeded")

    async def get_optimized_routes(self, start: str, end: str, preferences: dict) -> List[TransitResponse]:
        # Fetch raw transit data
        transit_data = await self.fetch_transit_data(start, end)
        
        # Format prompt for Gemini
        prompt = f"""
        Given the following transit data and user preferences, generate optimized multimodal transit routes.
        Transit Data: {json.dumps(transit_data)}
        Preferences: {json.dumps(preferences.dict())}
        Include safety considerations and crowding levels if available.
        Return a JSON list of routes with route_id, total_duration, total_cost, steps (mode, start, end, duration, cost, crowding_level), and safety_alerts.
        """
        
        # Call Gemini API
        gemini_response = await self.gemini_service.call_gemini(prompt)
        
        # Parse and validate Gemini response
        routes = gemini_response.get("routes", [])
        if not routes:
            raise HTTPException(status_code=500, detail="No routes generated by Gemini")
        
        # Convert to Pydantic models
        return [
            TransitResponse(
                route_id=route["route_id"],
                total_duration=route["total_duration"],
                total_cost=route["total_cost"],
                steps=[TransitRouteStep(**step) for step in route["steps"]],
                safety_alerts=route.get("safety_alerts", [])
            )
            for route in routes
        ]